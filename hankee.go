package main

import (
	"fmt"
	"log"
	"math/rand"
	"os"

	"github.com/hajimehoshi/ebiten/v2"
	"github.com/hajimehoshi/ebiten/v2/inpututil"
)

type Game struct {
	pixels   []byte
	keys     []ebiten.Key
	cpu      *CPU
	callback func(cpu *CPU)
}

func (g *Game) Update() error {
	g.keys = inpututil.AppendPressedKeys(g.keys[:0])
	// fmt.Println(g.keys)
	g.cpu.tickWithCallback(g.callback)
	return nil
}

func (g *Game) Draw(screen *ebiten.Image) {
	// for i := range g.pixels {
	// 	g.pixels[i] = 0x80
	// }
	screen.WritePixels(g.pixels)
}

func (g *Game) Layout(outsideWidth, outsideHeight int) (screenWidth, screenHeight int) {
	return 32, 32
}

func handleUserInput(cpu *CPU, keys []ebiten.Key) {
	for _, key := range keys {
		switch key {
		case ebiten.KeyEscape:
			os.Exit(0)
		case ebiten.KeyUp:
			cpu.memWrite(0xff, 0x77)
		case ebiten.KeyDown:
			cpu.memWrite(0xff, 0x73)
		case ebiten.KeyLeft:
			cpu.memWrite(0xff, 0x61)
		case ebiten.KeyRight:
			cpu.memWrite(0xff, 0x64)
		default:
			return
		}
	}
}

func getColor(byte uint8) []byte {
	switch byte {
	case 0:
		return []uint8{0xFF, 0xFF, 0xFF}
	case 1:
		return []uint8{0x00, 0x00, 0x00}
	case 2, 9:
		return []uint8{0x80, 0x80, 0x80}
	case 3, 10:
		return []uint8{0xFF, 0x00, 0x00}
	case 4, 11:
		return []uint8{0x00, 0xFF, 0x00}
	case 5, 12:
		return []uint8{0x00, 0x00, 0xFF}
	case 6, 13:
		return []uint8{0xFF, 0x00, 0xFF}
	case 7, 14:
		return []uint8{0xFF, 0xFF, 0x00}
	default:
		return []uint8{0x00, 0xFF, 0xFF}
	}
}

func readScreenState(cpu *CPU, g *Game) {
	frameIdx := 0
	pixelIdx := 0
	screen := make([]uint8, 1025)
	for i := 0x0200; i <= 0x600; i++ {
		colorIdx := cpu.memRead(uint16(i))
		screen[pixelIdx] = colorIdx
		color := getColor(colorIdx)
		g.pixels[frameIdx] = color[0]
		g.pixels[frameIdx+1] = color[1]
		g.pixels[frameIdx+2] = color[2]
		g.pixels[frameIdx+3] = 0xFF
		frameIdx += 3
		pixelIdx += 1
	}
	fmt.Println(screen)
}

func main() {
	cpu := NewCPU()

	snakeProgram := []uint8{
		0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02, 0x85,
		0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9, 0x0f, 0x85,
		0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85, 0x00, 0xa5, 0xfe,
		0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20, 0x8d, 0x06, 0x20, 0xc3,
		0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c, 0x38, 0x06, 0xa5, 0xff, 0xc9,
		0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0, 0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60,
		0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85, 0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0,
		0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01, 0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02,
		0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05, 0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06,
		0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00, 0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07,
		0xe6, 0x03, 0xe6, 0x03, 0x20, 0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06,
		0xb5, 0x11, 0xc5, 0x11, 0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c,
		0x35, 0x07, 0x60, 0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02,
		0x4a, 0xb0, 0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9,
		0x20, 0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
		0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10, 0xb0,
		0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5, 0x10, 0x29,
		0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe, 0x91, 0x00, 0x60,
		0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10, 0x60, 0xa2, 0x00, 0xea,
		0xea, 0xca, 0xd0, 0xfb, 0x60,
	}

	cpu.load(snakeProgram)
	cpu.reset()
	g := &Game{
		cpu:    cpu,
		pixels: make([]byte, 32*32*4),
	}

	g.callback = func(cpu *CPU) {
		handleUserInput(cpu, g.keys)
		cpu.memWrite(0xfe, uint8(rand.Intn(16-1)+1))
		readScreenState(cpu, g)
	}

	ebiten.SetWindowSize(32*10, 32*10)
	ebiten.SetWindowTitle("Hello, World!")
	ebiten.SetWindowResizingMode(ebiten.WindowResizingModeEnabled)
	// ebiten.SetTPS(3)
	if err := ebiten.RunGame(g); err != nil {
		log.Fatal(err)
	}
}
